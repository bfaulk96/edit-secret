#!/usr/bin/env python3

import argparse
import subprocess
import json
import os
from base64 import standard_b64decode, standard_b64encode
import shutil
import sys
import time

# must `pip install prompt_toolkit==1.0.14`
# must `pip install PyInquirer`
from PyInquirer import prompt

# Pare arguments passed in via command line
parser = argparse.ArgumentParser(description='Process some options')
parser.add_argument('--namespace', '-n', dest="namespace", help='specify a Kubernetes namespace')
parser.add_argument('name', type=str, help='the secret name')
args = parser.parse_args()

# Set the important variables
namespace = args.namespace
secret_name = args.name


def clear_line():
    sys.stdout.write('\r')
    sys.stdout.write("\033[K")
    sys.stdout.flush()


def main():
    print("Loading...", end='')

    # Use kubectl, the Kubernetes CLI, to get the specified secret
    result = subprocess.run(['kubectl', 'get', 'secret', '-n', namespace, secret_name, '-o', 'json'],
                            stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    output = result.stdout.decode('utf-8')
    err = result.stderr.decode('utf-8').rstrip()
    if err is not None and err is not "":
        clear_line()
        sys.exit(err)

    # Load the JSON file, capture the data attribute we care about
    res = json.loads(output)
    data = res.get("data", {})
    keys = [key for key in data]

    os.makedirs(".__temp__/", exist_ok=True)

    clear_line()

    EXIT_EDIT = False
    MAKE_CHANGES = True
    while not EXIT_EDIT:
        choices = ["%d) %s" % (index + 1, key) for index, key in enumerate(keys)]
        choices.append("%d) ADD" % (len(keys) + 1))
        choices.append("%d) CANCEL" % (len(keys) + 2))
        choices.append("%d) DONE" % (len(keys) + 3))

        questions = [
            {
                'type': 'list',
                'name': 'choice',
                'choices': choices,
                'default': "%d" % (len(keys) + 2),
                'message': 'Please choose what to edit:',
            }
        ]

        answer = prompt(questions)
        i = answer.get("choice", "%d" % (len(keys) + 2)).split(")")[0]

        sys.stdout.write("\033[F")
        clear_line()

        if not i.isdigit() or int(i) < 1:
            print("Please enter a digit!\n")
            continue
        else:
            i = int(i)
            if i == (len(keys) + 1):  # ADD
                name = input("Please enter the name of new file/literal: ")
                keys.append(name)
                filename = ".__temp__/__temp__%s" % name
                subprocess.run(["touch", filename])
            elif i == (len(keys) + 2):  # CANCEL
                EXIT_EDIT = True
                MAKE_CHANGES = False
                print("all changes have been cancelled")
                continue
            elif i == (len(keys) + 3):  # DONE
                EXIT_EDIT = True
                continue
            else:
                try:
                    name = keys[i - 1]  # SELECTION MADE
                    filename = ".__temp__/__temp__%s" % name
                    with open(filename, 'w') as f:
                        f.write(standard_b64decode(data[name]).decode("utf-8"))
                except IndexError:
                    print("Please select a valid number!\n")
                    continue

            a = subprocess.run(['vim', filename])

            with open(filename, 'r') as f:
                contents = f.read().rstrip()
                if len(contents) == 0:
                    if name in res["data"]:
                        del res["data"][name]
                    del_index = keys.index(name)
                    keys.pop(del_index)
                else:
                    res["data"][name] = standard_b64encode(bytes(contents, 'utf-8')).decode("utf-8")

    if MAKE_CHANGES:
        with open(".__temp__/__temp__.json", "w") as w:
            w.write(json.dumps(res))
        subprocess.run(["kubectl", "apply", "-f", ".__temp__/__temp__.json"])

    if os.path.exists(".__temp__"):
        shutil.rmtree('.__temp__')


main()
